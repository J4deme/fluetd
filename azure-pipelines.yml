trigger:
  branches:
    include:
      - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  azureSubscription: 'destrong-arm'
  dockerRegistryServiceConnection: '6862ce6f-7d49-40b0-9089-ed610706205c'
  imageRepository: 'bestrong'
  containerRegistry: 'bestrongaksacr12.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  tag: '$(Build.BuildId)'

stages:
# ===== BUILD =====
- stage: Build
  displayName: Build and Push Docker Image
  jobs:
    - job: DockerBuild
      displayName: Build and Push Image
      steps:
        - task: Docker@2
          displayName: Build and Push Docker Image
          inputs:
            command: buildAndPush
            repository: $(imageRepository)
            dockerfile: $(dockerfilePath)
            containerRegistry: $(dockerRegistryServiceConnection)
            tags: |
              $(tag)

# ===== HTTPS SETUP =====
- stage: SetupHTTPS
  displayName: 'Setup HTTPS using Ingress and cert-manager'
  dependsOn: Build
  jobs:
    - job: ConfigureIngress
      displayName: 'Install Ingress + TLS'
      steps:

        - task: AzureCLI@2
          displayName: 'Get AKS Credentials'
          inputs:
            azureSubscription: $(azureSubscription)
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              az aks get-credentials --resource-group bestrongAKS-rg --name bestrongAKS12

        - task: HelmInstaller@1
          inputs:
            helmVersionToInstall: 'latest'

        - script: |
            helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
            helm repo update
          displayName: 'Add NGINX Repo'

        - task: AzureCLI@2
          displayName: 'Create Static Public IP'
          inputs:
            azureSubscription: $(azureSubscription)
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              az network public-ip create \
                --resource-group "MC_bestrongAKS-rg_bestrongAKS12_westeurope" \
                --name bestrong-ingress-ip \
                --sku Standard \
                --allocation-method static \
                --location westeurope

              IP_ADDRESS=$(az network public-ip show \
                --resource-group "MC_bestrongAKS-rg_bestrongAKS12_westeurope" \
                --name bestrong-ingress-ip \
                --query ipAddress -o tsv)
              echo "##vso[task.setvariable variable=staticIpAddress]$IP_ADDRESS"

        - script: |
            # Uninstall existing ingress controller if any
            helm uninstall nginx-ingress --namespace default || true
            
            # Wait a moment to ensure resources are cleaned up
            sleep 10
            
            # Видаляємо всі існуючі ValidatingWebhookConfigurations для nginx (потенційна проблема)
            kubectl delete validatingwebhookconfiguration ingress-nginx-admission --ignore-not-found
            
            echo "Installing NGINX Ingress Controller with simplified configuration..."
            # Simplified Ingress Controller installation - removed problematic webhook parameters
            helm install nginx-ingress ingress-nginx/ingress-nginx \
              --set controller.service.loadBalancerIP=$(staticIpAddress) \
              --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
              
            echo "Waiting for external IP..."
            for i in {1..30}; do
              IP=$(kubectl get svc nginx-ingress-ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              if [[ ! -z "$IP" ]]; then
                echo "IP assigned: $IP"
                break
              fi
              sleep 10
            done
            
            # Verify Ingress Controller deployment success
            echo "Checking NGINX Ingress Controller pods..."
            kubectl get pods -l app.kubernetes.io/name=ingress-nginx
            kubectl get pods -l app.kubernetes.io/instance=nginx-ingress
            
            # Verify if pods are actually running
            INGRESS_POD_COUNT=$(kubectl get pods -l app.kubernetes.io/instance=nginx-ingress --no-headers | grep -c "Running" || echo "0")
            if [ "$INGRESS_POD_COUNT" -eq "0" ]; then
              echo "##vso[task.logissue type=warning]No running Ingress Controller pods found. Deployment might have failed."
              kubectl get pods -l app.kubernetes.io/instance=nginx-ingress -o yaml
              echo "Getting more information about potential issues:"
              kubectl describe pods -l app.kubernetes.io/instance=nginx-ingress
            else
              echo "Ingress Controller successfully deployed with $INGRESS_POD_COUNT running pods."
            fi
            
            # Check for services
            echo "Checking Ingress Controller services..."
            kubectl get svc -l app.kubernetes.io/name=ingress-nginx
            
            echo "##vso[task.setvariable variable=ingressIP;isOutput=true]$IP"
            echo "##vso[task.setvariable variable=ingressIP]$IP"
          displayName: 'Install NGINX Ingress'
          name: ingressInstall

        - script: |
            helm repo add jetstack https://charts.jetstack.io
            helm repo update
            kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.12.0/cert-manager.crds.yaml
            helm install cert-manager jetstack/cert-manager \
              --namespace cert-manager \
              --create-namespace \
              --version v1.12.0
            kubectl -n cert-manager wait --for=condition=available --timeout=120s deployment/cert-manager
            kubectl -n cert-manager wait --for=condition=available --timeout=120s deployment/cert-manager-webhook
          displayName: 'Install cert-manager'

        - script: |
            # Wait for Nginx Ingress controller to be fully ready
            echo "Ensuring Ingress controller is fully ready..."
            kubectl rollout status deployment/nginx-ingress-ingress-nginx-controller --timeout=180s || true
            
            # Verify if pods are actually running before proceeding with TLS setup
            INGRESS_READY=$(kubectl get pods -l app.kubernetes.io/instance=nginx-ingress --no-headers | grep -c "Running" || echo "0")
            if [ "$INGRESS_READY" -eq "0" ]; then
              echo "##vso[task.logissue type=warning]No running Ingress Controller pods found before configuring TLS."
              echo "Will proceed with TLS configuration but this might not work properly."
            fi
            
            # Get external IP address
            INGRESS_IP=$(kubectl get svc nginx-ingress-ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            echo "Using Ingress IP: $INGRESS_IP"
            
            if [ -z "$INGRESS_IP" ]; then
              echo "##vso[task.logissue type=error]Failed to get Ingress IP address. Cannot proceed with TLS setup."
              exit 1
            fi
            
            DOMAIN="bestrong.$INGRESS_IP.nip.io"
            echo "Setting up TLS for domain: $DOMAIN"
            
            cat <<EOF > tls.yaml
            apiVersion: cert-manager.io/v1
            kind: ClusterIssuer
            metadata:
              name: selfsigned-cluster-issuer
            spec:
              selfSigned: {}
            ---
            apiVersion: cert-manager.io/v1
            kind: Certificate
            metadata:
              name: bestrong-tls
              namespace: default
            spec:
              dnsNames:
                - $DOMAIN
              secretName: bestrong-tls-secret
              issuerRef:
                name: selfsigned-cluster-issuer
                kind: ClusterIssuer
              commonName: $DOMAIN
            EOF
            
            kubectl apply -f tls.yaml
            echo "Applied TLS configuration"
            
            # Wait for certificate to be created
            echo "Waiting for certificate to be ready..."
            sleep 10
            kubectl wait --for=condition=Ready certificate/bestrong-tls --timeout=60s || echo "Certificate might not be ready yet"
            
            # Display certificate status
            echo "Certificate status:"
            kubectl get certificate bestrong-tls -o wide
          displayName: 'Configure TLS for Ingress'

# ===== HELM DEPLOY =====
- stage: HelmDeploy
  displayName: 'Deploy App via Helm'
  dependsOn: SetupHTTPS
  variables:
    ingressIP: $[ stageDependencies.SetupHTTPS.ConfigureIngress.outputs['ingressInstall.ingressIP'] ]
    chartVersion: '1.0.0-$(Build.BuildId)'
    helmChartName: 'bestrongapp'
    acrUrl: '$(containerRegistry)'
  jobs:
    - job: DeployApp
      steps:

        - task: AzureCLI@2
          displayName: 'AKS Credentials'
          inputs:
            azureSubscription: $(azureSubscription)
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              az aks get-credentials --resource-group bestrongAKS-rg --name bestrongAKS12

        - task: HelmInstaller@1
          inputs:
            helmVersionToInstall: 'latest'

        - script: |
            helm package helm/ --version $(chartVersion)
          displayName: 'Package Helm Chart'

        - script: |
            export HELM_EXPERIMENTAL_OCI=1
            helm registry login $(acrUrl) --username $(acrUsername) --password $(acrPassword)
            helm push $(helmChartName)-$(chartVersion).tgz oci://$(acrUrl)/helm
          displayName: 'Push Helm Chart to ACR'
          env:
            acrUsername: $(acrUsername)
            acrPassword: $(acrPassword)

        - script: |
            export HELM_EXPERIMENTAL_OCI=1
            helm registry login $(acrUrl) --username $(acrUsername) --password $(acrPassword)
            helm pull oci://$(acrUrl)/helm/$(helmChartName) --version $(chartVersion)

            # Fetch IP directly if variable is not set
            if [ -z "$(ingressIP)" ]; then
              INGRESS_IP=$(kubectl get svc nginx-ingress-ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              echo "Using directly fetched IP: $INGRESS_IP"
            else
              INGRESS_IP=$(ingressIP)
              echo "Using pipeline variable IP: $INGRESS_IP"
            fi

            # Validation to ensure we don't create invalid hostnames
            if [ -z "$INGRESS_IP" ]; then
              echo "##vso[task.logissue type=error]No Ingress IP found. Cannot proceed with deployment."
              exit 1
            fi

            INGRESS_HOST="bestrong.$INGRESS_IP.nip.io"
            echo "Using ingress host: $INGRESS_HOST"
            
            # Verify pre-requisites before deployment
            echo "Checking prerequisites for deployment..."
            
            # Check if Ingress Controller is running
            INGRESS_READY=$(kubectl get pods -l app.kubernetes.io/instance=nginx-ingress --no-headers | grep -c "Running" || echo "0")
            echo "Number of running Ingress Controller pods: $INGRESS_READY"
            
            # Check if TLS certificate is available
            if kubectl get secret bestrong-tls-secret &>/dev/null; then
              echo "TLS certificate found and ready to use"
            else
              echo "##vso[task.logissue type=warning]TLS certificate secret not found. HTTPS might not work."
            fi
            
            # Properly cleanup existing deployments
            echo "Cleaning up existing deployments..."
            
            # Main application
            kubectl delete ingress bestrongapp-ing --ignore-not-found
            helm uninstall $(helmChartName) --namespace default || true
            kubectl delete all -l app.kubernetes.io/instance=$(helmChartName) --namespace default --ignore-not-found
            sleep 5
            
            echo "Installing main application..."
            helm install $(helmChartName) $(helmChartName)-$(chartVersion).tgz \
              --set image.repository=$(acrUrl)/$(imageRepository) \
              --set image.tag=$(tag) \
              --set ingress.host=$INGRESS_HOST \
              --values ./helm/values.yaml \
              --namespace default --create-namespace \
              --timeout 5m0s
            
            # Check deployment status
            echo "Checking main deployment status..."
            kubectl rollout status deployment/bestrongapp-deploy --timeout=180s
            
            # Canary application
            echo "Cleaning up existing canary deployments..."
            kubectl delete ingress bestrongapp-canary-ing --ignore-not-found
            helm uninstall $(helmChartName)-canary --namespace default || true
            kubectl delete all -l app.kubernetes.io/instance=$(helmChartName)-canary --namespace default --ignore-not-found
            sleep 5
            
            echo "Installing canary application..."
            helm install $(helmChartName)-canary $(helmChartName)-$(chartVersion).tgz \
              --set image.repository=$(acrUrl)/$(imageRepository) \
              --set image.tag=$(Build.BuildId) \
              --set ingress.host=$INGRESS_HOST \
              --values ./helm/values-canary.yaml \
              --namespace default \
              --timeout 5m0s
            
            # Check canary deployment status
            echo "Checking canary deployment status..."
            kubectl rollout status deployment/bestrongapp-canary-deploy --timeout=180s
            
            # Final verification and information
            echo "Deployment information:"
            echo "Main app running: $(kubectl get pods -l app.kubernetes.io/instance=$(helmChartName) -o jsonpath='{.items[0].status.phase}' || echo 'Unknown')"
            echo "Canary app running: $(kubectl get pods -l app.kubernetes.io/instance=$(helmChartName)-canary -o jsonpath='{.items[0].status.phase}' || echo 'Unknown')"
            echo "Ingress information:"
            kubectl get ingress
            echo "Successful deployment. Application should be available at:"
            echo "http://$INGRESS_HOST"
            echo "https://$INGRESS_HOST (if TLS is properly configured)"
          displayName: 'Deploy Helm Chart to AKS'
          env:
            acrUsername: $(acrUsername)
            acrPassword: $(acrPassword)